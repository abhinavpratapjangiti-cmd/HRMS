const express = require("express");
const router = express.Router();
const db = require("../db"); // mysql2/promise pool
const bcrypt = require("bcryptjs");
const { verifyToken } = require("../middleware/auth");
const { pushNotification } = require("./wsServer");

/* ==========================================================================
   CONSTANTS & CONFIG
   ========================================================================== */
// FIX: Added 'intern' so the server accepts it from the frontend dropdown
const ALLOWED_ROLES = ["employee", "manager", "hr", "admin", "intern"];
const USER_CREATORS = ["admin", "hr"];


/* ==========================================================================
   0. UPDATE MY OWN PROFILE (Matches PATCH /api/users/me)
   ðŸš€ THIS BYPASSES THE ADMIN CHECK! ðŸš€
   ========================================================================== */
router.patch("/me", verifyToken, async (req, res) => {
  const { email, department, designation, phoneno } = req.body;
  const connection = await db.getConnection();

  try {
    await connection.beginTransaction();

    // 1. Update Users Table (Keep email in sync for login)
    if (email) {
      await connection.query("UPDATE users SET email = ? WHERE id = ?", [email, req.user.id]);
    }

    // 2. Update Employees Table
    const empUpdates = [];
    const empValues = [];

    if (email) { empUpdates.push("email = ?"); empValues.push(email); }
    if (department) { empUpdates.push("department = ?"); empValues.push(department); }
    if (designation) { empUpdates.push("designation = ?"); empValues.push(designation); }
    if (phoneno) { empUpdates.push("phoneno = ?"); empValues.push(phoneno); }

    if (empUpdates.length > 0) {
        empValues.push(req.user.id);
        await connection.query(`UPDATE employees SET ${empUpdates.join(", ")} WHERE user_id = ?`, empValues);
    }

    await connection.commit();
    res.json({ success: true, message: "Profile updated successfully" });

  } catch (err) {
    if (connection) await connection.rollback();
    console.error("SELF UPDATE ERROR:", err);
    res.status(500).json({ message: "Update failed" });
  } finally {
    if (connection) connection.release();
  }
});

/* ==========================================================================
   1. CREATE EMPLOYEE (POST /)
   Creates both User (login) and Employee (profile) records
   ========================================================================== */
router.post("/", verifyToken, async (req, res) => {
  const connection = await db.getConnection(); // Use transaction for atomicity
  try {
    // 1. Permission Check
    if (!USER_CREATORS.includes(req.user.role)) {
      connection.release();
      return res.status(403).json({ message: "Admin / HR only" });
    }

    // 2. Destructure Payload
    const {
      name,
      email,
      password,
      role = "employee",
      department = "IT",
      work_location = "Remote",
      designation = null, // FIX: Capture designation
      manager_id = null,
      phone = null
    } = req.body;

    const client_name = req.body.client_name || req.body.client || "Internal";

    // 3. Validation
    if (!name || !email) {
      connection.release();
      return res.status(400).json({ message: "Name and Email are required" });
    }

    if (!ALLOWED_ROLES.includes(role.toLowerCase())) {
      connection.release();
      return res.status(400).json({ message: `Invalid role. Allowed: ${ALLOWED_ROLES.join(', ')}` });
    }

    await connection.beginTransaction();

    // 4. Check Duplicate Email
    const [existing] = await connection.query("SELECT id FROM users WHERE email = ?", [email]);
    if (existing.length) {
      await connection.rollback();
      connection.release();
      return res.status(409).json({ message: "User with this email already exists" });
    }

    // 5. Create User (Login Credentials)
    const finalPassword = password && password.trim() ? password.trim() : Math.random().toString(36).slice(-10);
    const hashedPassword = await bcrypt.hash(finalPassword, 10);

    const [userResult] = await connection.query(
      `INSERT INTO users (name, email, password, role) VALUES (?, ?, ?, ?)`,
      [name, email, hashedPassword, role.toLowerCase()]
    );
    const userId = userResult.insertId;

    // 6. Create Employee (Profile Details)
    // FIX: Insert designation properly
    const finalManagerId = manager_id && manager_id !== "" ? manager_id : null;

    await connection.query(
      `INSERT INTO employees
      (user_id, name, email, department, client_name, work_location, designation, manager_id, active)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1)`,
      [userId, name, email, department, client_name, work_location, designation, finalManagerId,]
    );

    await connection.commit();

    // 7. Notifications (Async - Non blocking)
    (async () => {
      try {
        const [hrs] = await db.query("SELECT id FROM users WHERE LOWER(role) = 'hr'");
        for (const hr of hrs) {
          const [n] = await db.query(
            `INSERT INTO notifications (user_id, type, message, is_read) VALUES (?, 'user', ?, 0)`,
            [hr.id, `New employee ${name} was added`]
          );
          if (typeof pushNotification === 'function') {
            pushNotification(hr.id, {
              id: n.insertId,
              type: "user",
              message: `New employee ${name} was added`,
              created_at: new Date()
            });
          }
        }
      } catch (e) {
        console.warn("Notification skipped:", e.message);
      }
    })();

    res.status(201).json({ message: "Employee created successfully", user_id: userId });

  } catch (err) {
    if (connection) await connection.rollback();
    console.error("CREATE EMPLOYEE ERROR:", err);
    res.status(500).json({ message: "Server error" });
  } finally {
    if (connection) connection.release();
  }
});

/* ==========================================================================
   2. LIST EMPLOYEES (GET /)
   Fetches the table data, including the new designation column
   ========================================================================== */
router.get("/", verifyToken, async (req, res) => {
  try {
    if (!USER_CREATORS.includes(req.user.role)) {
      return res.status(403).json({ message: "Admin / HR only" });
    }

    // FIX: Selected 'e.designation' so it appears in the frontend table
    const [rows] = await db.query(
      `SELECT
        e.id AS employee_id,
        u.id AS user_id,
        e.name,
        e.email,
        u.role,
        e.department,
        e.designation,
        e.manager_id,
        m.name AS manager_name,
        e.active
      FROM employees e
      JOIN users u ON u.id = e.user_id
      LEFT JOIN employees m ON m.id = e.manager_id
      ORDER BY e.name ASC`
    );

    res.json(rows);

  } catch (err) {
    console.error("LIST USERS ERROR:", err);
    res.status(500).json({ message: "DB error" });
  }
});

/* ==========================================================================
   3. LIST MANAGERS (GET /managers)
   Used for the dropdowns
   ========================================================================== */
router.get("/managers", verifyToken, async (req, res) => {
  try {
    if (!USER_CREATORS.includes(req.user.role)) {
      return res.status(403).json({ message: "Admin / HR only" });
    }

    const [rows] = await db.query(
      `SELECT e.id AS employee_id, u.id AS user_id, e.name, e.email
      FROM employees e
      JOIN users u ON u.id = e.user_id
      WHERE LOWER(u.role) IN ('manager', 'admin', 'hr')
      AND e.active = 1
      ORDER BY e.name`
    );

    res.json(rows);

  } catch (err) {
    console.error("FETCH MANAGERS ERROR:", err);
    res.status(500).json({ message: "DB error" });
  }
});

/* ==========================================================================
   4. ORG SNAPSHOT STATS (GET /stats)
   ========================================================================== */
router.get("/stats", verifyToken, async (req, res) => {
  try {
    // FIX ISSUE 3: Correct counting logic using subqueries
    // Total: All employees in database
    // Managers: Active Employees who have User Role 'manager'
    // Active: All active employees
    const [rows] = await db.query(
      `SELECT
        (SELECT COUNT(*) FROM employees) as total,
        (SELECT COUNT(*) FROM employees e
         JOIN users u ON e.user_id = u.id
         WHERE u.role = 'manager' AND e.active = 1) as managers,
        (SELECT COUNT(*) FROM employees WHERE active = 1) as active`
    );

    res.json(rows[0] || { total: 0, managers: 0, active: 0 });
  } catch (err) {
    console.error("STATS ERROR:", err);
    res.status(500).json({ message: "DB error" });
  }
});

/* ==========================================================================
   5. DEPARTMENT DISTRIBUTION (GET /departments)
   ========================================================================== */
router.get("/departments", verifyToken, async (req, res) => {
  try {
    // FIX ISSUE 2: Added 'WHERE active = 1' to only count current employees
    const [rows] = await db.query(
      `SELECT department, COUNT(*) AS count
      FROM employees
      WHERE active = 1 AND department IS NOT NULL AND department != ''
      GROUP BY department
      ORDER BY count DESC`
    );

    res.json(rows);
  } catch (err) {
    console.error("DEPARTMENT ERROR:", err);
    res.status(500).json({ message: "DB error" });
  }
});

/* ==========================================================================
   6. UPDATE USER ROLE (PATCH /:userId/role)
   ========================================================================== */
router.patch("/:userId/role", verifyToken, async (req, res) => {
  try {
    if (!USER_CREATORS.includes(req.user.role)) {
      return res.status(403).json({ message: "Admin / HR only" });
    }

    const { userId } = req.params;
    const { role } = req.body;

    if (!ALLOWED_ROLES.includes(role.toLowerCase())) {
      return res.status(400).json({ message: "Invalid role" });
    }

    if (Number(userId) === req.user.id) {
      return res.status(400).json({ message: "You cannot change your own role" });
    }

    await db.query("UPDATE users SET role = ? WHERE id = ?", [role.toLowerCase(), userId]);
    res.json({ message: "Role updated successfully" });

  } catch (err) {
    console.error("UPDATE ROLE ERROR:", err);
    res.status(500).json({ message: "Server error" });
  }
});

/* ==========================================================================
   7. UPDATE REPORTING MANAGER (PATCH /:employeeId/manager)
   (Kept for backward compatibility if needed, but logic is also in generic patch)
   ========================================================================== */
router.patch("/:employeeId/manager", verifyToken, async (req, res) => {
  try {
    if (!USER_CREATORS.includes(req.user.role)) {
      return res.status(403).json({ message: "Admin / HR only" });
    }

    const { employeeId } = req.params;
    let { manager_id } = req.body;

    if (manager_id === "") manager_id = null;

    if (manager_id && Number(employeeId) === Number(manager_id)) {
      return res.status(400).json({ message: "Employee cannot be their own manager" });
    }

    await db.query("UPDATE employees SET manager_id = ? WHERE id = ?", [manager_id || null, employeeId]);
    res.json({ message: "Reporting manager updated" });

  } catch (err) {
    console.error("UPDATE MANAGER ERROR:", err);
    res.status(500).json({ message: "Server error" });
  }
});



/* ==========================================================================
   9. DELETE EMPLOYEE (DELETE /:employeeId)
   ========================================================================== */
router.delete("/:employeeId", verifyToken, async (req, res) => {
  const connection = await db.getConnection();
  try {
    if (!USER_CREATORS.includes(req.user.role)) {
      connection.release();
      return res.status(403).json({ message: "Admin / HR only" });
    }

    const { employeeId } = req.params;

    const [emp] = await connection.query("SELECT user_id, name FROM employees WHERE id = ?", [employeeId]);

    if (emp.length === 0) {
      connection.release();
      return res.status(404).json({ message: "Employee not found" });
    }

    const targetUserId = emp[0].user_id;
    const targetName = emp[0].name;

    if (targetUserId === req.user.id) {
      connection.release();
      return res.status(400).json({ message: "You cannot delete yourself." });
    }

    await connection.beginTransaction();

    await connection.query("DELETE FROM employees WHERE id = ?", [employeeId]);
    await connection.query("DELETE FROM users WHERE id = ?", [targetUserId]);

    await connection.commit();

    console.log(`Deleted employee ${targetName} (ID: ${employeeId})`);
    res.json({ message: "Employee deleted successfully" });

  } catch (err) {
    if (connection) await connection.rollback();
    console.error("DELETE ERROR:", err);
    res.status(500).json({ message: "Server error during deletion" });
  } finally {
    if (connection) connection.release();
  }
});

module.exports = router;
